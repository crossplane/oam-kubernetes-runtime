# Traits/Scopes and workloads interaction mechanism in OAM

* Owner: Ryan Zhang (@ryanzhang-oss)
* Reviewers: Crossplane Maintainers
* Status: Implemented

## Terminology

* **CRD (Custom Resource Definition)** : A standard Kubernetes Custom Resource Definition
* **CR (Custom Resource)** : An instance of a Kubernetes type that was defined using a CRD
* **GVK (Group Version Kind)** : The API Group, Version, and Kind for a type of Kubernetes
 resource (including CRDs)
* **Workload child resources** : The Kubernetes resources generated by a workload controller. They
 should all have a controller reference pointing to the parent workload instance.

## Background

 **Please notice that Traits and Scopes share the same issue on this topic, and we just use Trait to state the problem in this section.**

Traits and workloads are two major types of resources in OAM. Traits usually affect how a
kubernetes resource operate either directly (through spec change) or indirectly (add ingress or
sidecar). However, the current OAM implementation does not contain a generic mechanism for traits
 to locate the corresponding resource to modify. 
 
We will use the following hypothetical OAM application as the baseline to illustrate the problem
 and our solution.
 
```yaml
apiVersion: core.oam.dev/v1alpha2
kind: WorkloadDefinition
metadata:
  name: mydbs.standard.oam.dev
spec:
  definitionRef:
    name: mydbs.standard.oam.dev
---
apiVersion: core.oam.dev/v1alpha2
kind: TraitDefinition
metadata:
  name: manualscalertraits.core.oam.dev
spec:
  definitionRef:
    name: manualscalertraits.core.oam.dev
---
apiVersion: core.oam.dev/v1alpha2
kind: Component
metadata:
  name: example-db
spec:
  workload:
    apiVersion: standard.oam.dev/v1alpha2
    kind: Mydb
    metadata:
      name: mydb-example
    spec:
      containers:
        - name: mysql
          image: mysql:latest
---
apiVersion: core.oam.dev/v1alpha2
kind: ApplicationConfiguration
metadata:
  name: example-appconfig
spec:
  components:
     - componentName: example-db      
       traits:
         - trait:
             apiVersion: core.oam.dev/v1alpha2
             kind: ManualScalerTrait
             metadata:
               name:  example-appconfig-trait
             spec:
               replicaCount: 3
```

The problem is two folds
1. A trait controller needs a way to find the workload that it is applied to. 
   - In the example, the manual scalar trait needs to know that it is supposed to scale the
    example-db workload. However, we want to keep the applicationConfiguration controller
    agnostic to the schema of any `trait` or `workload` it generates to make it extensible.
    Thus, the applicationConfiguration controller needs to emit a `ManualScalerTrait` CR that
    contains a reference to the `example-db` workload without knowing the trait's specific schema.
    
2. A trait controller needs to know the exact resources it should modify. Note that these
resources are most likely not the workload itself.
    - Use the same example, just knowing the `example-db` workload is not enough for the
     `ManualScalerTrait` to work. The trait controller does not work with the `example-db` workload
      directly. It needs to find the actual Kubernetes resources that the `example-db`
     workload generates and then it can modify the `replica` field in its spec.

#### Same problem of Scope
Just like what happens to **trait**, scope also needs a generic mechanism to interact with workload. It's a crucial step for OAM implementation to make scope aware of which workloads are associated to it. Currently, OAM implementation assumes that every scope has a field `.spec.workloadRefs` to record associated workload references and get/set references in a hard-code way. 

Here's an example and `HealthScope` CRD refers to [here](https://github.com/crossplane/oam-kubernetes-runtime/blob/master/charts/oam-kubernetes-runtime/crds/core.oam.dev_healthscopes.yaml).
 
```yaml
apiVersion: core.oam.dev/v1alpha2
kind: ScopeDefinition
metadata:
  name: healthscope.core.oam.dev
spec:
  allowComponentOverlap: true
  definitionRef:
    name: healthscope.core.oam.dev
---
apiVersion: core.oam.dev/v1alpha2
kind: HealthScope
metadata:
  name: example-health-scope
---
apiVersion: core.oam.dev/v1alpha2
kind: ApplicationConfiguration
metadata:
  name: example-appconfig
spec:
  components:
    - componentName: example-db      
      traits:
      ...
      scopes:
        - scopeRef:
            apiVersion: core.oam.dev/v1alpha2
            kind: HealthScope
            name: example-health-scope
```


## Goals
In order to maximize the extensibility of our OAM implementation, our solution need to meet the
 following two design objections.
1. **Extensible trait system**: We want to allow a `trait` to apply to any eligible `workload`
instead of just a list of specific ones. This means that we want to empower a trait developer to
write the controller code once, and it will work for any new `workload` that this `trait` can
apply to in the future.
    - Using the example again, the `ManualScalerTrait` should work with any workload that
     generates a Kubernetes resource that has a `replica` field in its spec even if the
      workload does not exist when the `ManualScalerTrait` is implemented.
2. **Adopting existing CRDs**: The mechanism cannot put any limit on the `trait` or `workload
` CRDs. This means that we cannot assume any pre-defined CRD fields in any `trait` or `workload
` beyond Kubernetes conventions (i.e. spec or status).
    - For example, the following `EtcdBackup` operator can be used as a `trait` in an OAM
     application to apply to an `EtcdCluster` workload. Here, the `etcdEndPoints` field in
     the trait signals to which `workload` it applies, and we need to accommodate
     this type of `trait`. 
      ```yaml
      apiVersion: "etcd.database.coreos.com/v1beta2"
      kind: "EtcdBackup"
      metadata:
        name: example-etcd-cluster-backup
      spec:
        etcdEndpoints: [<etcd-cluster-endpoints>]
        storageType: S3
        s3:
          path: <full-s3-path>
          awsSecret: <aws-secret>
      ```

## Proposal

### Traits and workloads interaction mechanism
The overall idea is for the applicationConfiguration controller to fill critical information
in the workload and trait CR it emits. In addition, we will provide a helper library so that
trait controller developers can locate the resources they need with a simple function call. 
Here is the list of changes that we propose.
1. Add an optional field called `workloadRefPath` to the `traitDefinition` schema. This is for the 
 trait owner to declare that the trait relies on the OAM trait/workload interaction
 mechanism. The value of the field is the path to the field that takes a `workloadRef` object. In
 our example, the trait definition would look like below since our `manualscalertraits` takes
 the `workloadRef` field at `spec.workloadRef`.
     ```yaml
       apiVersion: core.oam.dev/v1alpha2
       kind: TraitDefinition
       metadata:
         name: manualscalertraits.core.oam.dev
       spec:
         workloadRefPath: spec.workloadRef
         definitionRef:
           name: manualscalertraits.core.oam.dev
     ```
2. ApplicationConfig controller no longer assumes that all `trait` CRDs contain a "spec
.workloadRef" field conforms to the OAM definition. It only fills the workload GVK to a `trait
` CR with "spec.workloadRef" field defined as below if the corresponding `traitDefiniton` has a
 "workloadRefPath" field.   
     ```yaml
       workloadRef:
         properties:
           apiVersion:
             type: string
           kind:
             type: string
           name:
             type: string
         required:
         - apiVersion
         - kind
         - name
         type: object
     ```
     

### Scopes and workloads interaction mechanism
1. Add an optional field called `workloadRefsPath` to the `scopeDefinition` schema. This is for the scope owner to declare that the scope relies on the OAM scope/workload interaction mechanism. 
The value of the field is the path to the field that takes `workloadRef` objects. 
In our example, the scope definition would look like below since our `HealthScope` takes the `workloadRef` field at `spec.workloadRefs`.
     ```yaml
       apiVersion: core.oam.dev/v1alpha2
       kind: ScopeDefinition
       metadata:
         name: healthscopes.core.oam.dev
       spec:
         workloadRefsPath: spec.workloadRefs
         definitionRef:
           name: healthscopes.core.oam.dev
     ```
2. ApplicationConfig controller no longer assumes that all Scope CRDs contain a `.spec.workloadRefs` field conforming to the OAM definition. It only fills the workload GVK to a Scope CR with `spec.workloadRefs` field defined as below if the corresponding `scopeDefiniton` has a `spec.workloadRefs` field.   
     ```yaml
       workloadRef:
         properties:
           apiVersion:
             type: string
           kind:
             type: string
           name:
             type: string
         required:
         - apiVersion
         - kind
         - name
         type: object
     ```

### Changes on WorkloadDefinition and Helper library
1. Add a `childResourceKinds` field in the  WorkloadDefinition. 
Currently, a workloadDefinition is nothing but a shim of a real workload CRD. We propose to add
an **optional** field called `childResourceKinds` to the schema of the workloadDefinition. We encourage
workload owners to fill in this field when they register their controllers to the OAM system. 
This is the way for them to declare the types of the Kubernetes resources their workload
controller actually generates. In our example, the workload definition can claim to generate
deployment and service child resources. 
    ```yaml
    apiVersion: core.oam.dev/v1alpha2
    kind: WorkloadDefinition
    metadata:
       name: mydb.standard.oam.dev
    spec:
      definitionRef:
         name: mydb.standard.oam.dev
      childResourceKinds:
         - apiVersion: apps/v1
           kind: Deployment
         - apiVersion: v1
           kind: Service      
    ```
2. OAM runtime will provide a helper library. The library follows the following logic to help a
 trait/scope developer locate the resources for the trait/scope to interact with.
    1. Get the corresponding `workload` instance from the Kubernetes cluster with the information
     inserted by the application controller in the `trait` CR.
    2. Fetch the corresponding `workloadDefinition` CR following an
       [OAM convention](https://github.com/oam-dev/spec/blob/master/3.workload.md#definitionref).
       The convention requires that the name of the `workloadDefinition` CR is the name of the
       `workload` CRD it refers to. For example, the name of the `workloadDefinition` CR
       that refers to a `containerizedworkloads.core.oam.dev` CRD is exactly
       `containerizedworkloads.core.oam.dev` as well. 
    3. Fetch all the `childResourceKinds` values in the corresponding`workloadDefinition` instance. 
    4. List each child resource by its GVK and filter by owner reference. Here, we assume that
     all the child resources that the workload controller generates have a controller reference
      field pointing back to the workload instance.

## Impact to the existing system
Here are the impacts of this mechanism to the existing OAM components
- ApplicationConfiguration: This mechanism requires minimum changes in the
 applicationConfiguration controller except that it now needs to check if a trait definition has a
  `spec.workloadRefPath` or if a scope definition has a `spec.workloadRefsPath` before patching the workloadRef field.
- Workload: This mechanism does not affect workload controller implementation.
- Trait: This mechanism is optional so all existing trait controller still works. This mechanism
requires modification to any existing trait and its traitDefinition that wants to take advantage of
the extensibility of OAM. Any trait that only applies to a certain type of workload, such as
 `EtcdBackup` trait, doesn't need to use this mechanism.
- WorkloadDefinition: workload owners can modify the existing workloadDefinition if needed.
- Scope & ScopeDefinitiion: This mechanism is optional so all existing scope controller still works. 
But for those scopes with `spec.workloadRefs`, their owner should add `spec.workloadRefsPath: spec.workloadRefs` in corresponding `scopeDefiniton`.  

## Alternative approach
1. One alternative approach is that we can make the applicationConfiguration controller watch all
the possible workload child resources. It also inserts the child resources GVK and name to the
corresponding workload CR. I would not recommend this approach as it increases the complexity
of the applicationConfiguration controller and makes more of availability liability. 
2. Another approach is to implement a separate type for binding traits to workloads. This would
 work, but it seems that label/annotation is a natural place to record the information. Otherwise
 , we need a way for the trait to discover the binding instance first.

## Extra labels
There might be cases that a workload generates more than one resource with the same GVK and only
want to expose a subset of them to traits. In this case, we can add a pre-defined label such as
`core.oam.dev/expose=true` for the workload owner to indicate what resources to expose. This
section is just to illustrate that this is a solvable problem, and it's beyond the scope of this
proposal for now .
